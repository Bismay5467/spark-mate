"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpHandler = exports.keepAliveSupport = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const querystring_builder_1 = require("@smithy/querystring-builder");
const request_timeout_1 = require("./request-timeout");
exports.keepAliveSupport = {
<<<<<<< HEAD
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
=======
    supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("")),
>>>>>>> 594587a5603a095d8cdcb0dc147d2dabd7ffb7d6
};
class FetchHttpHandler {
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options !== null && options !== void 0 ? options : {};
            this.configProvider = Promise.resolve(this.config);
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
<<<<<<< HEAD
        var _a, _b;
=======
        var _a, _b, _c;
>>>>>>> 594587a5603a095d8cdcb0dc147d2dabd7ffb7d6
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = this.config.requestTimeout;
<<<<<<< HEAD
        const keepAlive = this.config.keepAlive === true;
=======
        const keepAlive = (_a = this.config.keepAlive) !== null && _a !== void 0 ? _a : true;
>>>>>>> 594587a5603a095d8cdcb0dc147d2dabd7ffb7d6
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
<<<<<<< HEAD
            const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
            const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
=======
            const username = (_b = request.username) !== null && _b !== void 0 ? _b : "";
            const password = (_c = request.password) !== null && _c !== void 0 ? _c : "";
>>>>>>> 594587a5603a095d8cdcb0dc147d2dabd7ffb7d6
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
<<<<<<< HEAD
        const requestOptions = { body, headers: new Headers(request.headers), method: method };
=======
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
        };
>>>>>>> 594587a5603a095d8cdcb0dc147d2dabd7ffb7d6
        if (typeof AbortController !== "undefined") {
            requestOptions["signal"] = abortSignal;
        }
        if (exports.keepAliveSupport.supported) {
            requestOptions["keepalive"] = keepAlive;
        }
        const fetchRequest = new Request(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new protocol_http_1.HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new protocol_http_1.HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            (0, request_timeout_1.requestTimeout)(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                abortSignal.onabort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }));
        }
        return Promise.race(raceOfPromises);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        var _a;
        return (_a = this.config) !== null && _a !== void 0 ? _a : {};
    }
}
exports.FetchHttpHandler = FetchHttpHandler;
